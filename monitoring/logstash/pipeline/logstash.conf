input {
  s3 {
    # --- MinIO (S3) ---
    endpoint          => "${S3_SERVICE_URL}"                # пример: https://minio:9000
    region            => "us-east-1"                        # любая валидная строка для SDK
    access_key_id     => "${S3_ACCESS_KEY_ID}"              # RO-аккаунт для логов
    secret_access_key => "${S3_SECRET_ACCESS_KEY}"
    bucket            => "${BUCKET_LOGS}"                   # logs
    additional_settings => { "force_path_style" => true }   # ДЛЯ MinIO ОБЯЗАТЕЛЬНО
    interval          => 30                                 # опрос каждые 30 сек
    codec             => plain { charset => "UTF-8" }       # читаем строками
    sincedb_path      => "/usr/share/logstash/.sincedb_s3"  # чтобы не читать повторно
    include_object_properties => true                       # чтобы достать ключ объекта
  }
}

filter {
  # 1) Кладём ключ объекта S3 в @metadata.s3key
  ruby {
    code => '
      candidates = [
        "[@metadata][s3][key]",
        "[s3][object][key]",
        "[s3][object_key]",
        "[s3][key]",
        "[@metadata][s3][object][key]",
        "[@metadata][s3][object_key]"
      ]
      s3key = nil
      candidates.each do |path|
        v = event.get(path)
        if v && !v.to_s.empty?
          s3key = v.to_s
          break
        end
      end
      event.set("[@metadata][s3key]", s3key) if s3key
    '
  }

  # 2) job из ENV (для Loki-лейблов)
  mutate {
    add_field => { "[@metadata][job]" => "${LOKI_JOB_LABEL}" }
  }

  # 3) role = первый сегмент ключа (до /)
  ruby {
    code => '
      s3key = (event.get("[@metadata][s3key]") || "").to_s
      role  = s3key.split("/", 2)[0].to_s.strip.downcase
      role  = (ENV["ROLE_FALLBACK"] || "unknown").to_s if role.empty?
      event.set("role", role)
    '
  }

  # 4) Извлекаем env и log_type из имени файла:
  #    примеры:
  #      wt_dev.spxml_unibridge_2025-08-22.log
  #      wt_dev.xhttp_middleware_2025-08-22.0002195511.log
  ruby {
    code => '
      s3key = (event.get("[@metadata][s3key]") || "").to_s
      fname = File.basename(s3key)

      env = nil
      log_type = nil

      # env = всё до первой точки, log_type = между первой точкой и "_YYYY-MM-DD"
      if m = fname.match(/\A([^.]+)\.([A-Za-z0-9_.-]+?)_\d{4}-\d{2}-\d{2}(?:\.\d+)?\.log\z/)
        env      = m[1]
        log_type = m[2]
      end

      env      = (env || ENV["ENV_FALLBACK"] || "unknown").to_s.downcase
      log_type = (log_type || ENV["LOG_TYPE_FALLBACK"] || "unknown").to_s.downcase

      event.set("env", env)
      event.set("log_type", log_type)
    '
  }

  # 5) Готовим JSON для Loki
  ruby {
    code => '
      require "json"
      role      = (event.get("role")                  || ENV["ROLE_FALLBACK"]     || "unknown").to_s
      job       = (event.get("[@metadata][job]")      || "logs").to_s
      env       = (event.get("env")                   || ENV["ENV_FALLBACK"]      || "unknown").to_s
      log_type  = (event.get("log_type")              || ENV["LOG_TYPE_FALLBACK"] || "unknown").to_s
      msg       = (event.get("message")               || "").to_s

      ts = event.get("@timestamp")
      ts_nano = if ts.respond_to?(:time)
                  (ts.time.to_r * 1_000_000_000).to_i.to_s
                else
                  (Time.now.to_r * 1_000_000_000).to_i.to_s
                end

      payload = {
        "streams" => [
          {
            "stream" => {
              "job"      => job,
              "role"     => role,
              "env"      => env,
              "log_type" => log_type
            },
            "values" => [[ ts_nano, msg ]]
          }
        ]
      }
      event.set("[@metadata][loki_json]", payload.to_json)
    '
  }
}

output {
  # Шлём ГОТОВЫЙ JSON в Loki по HTTP
  http {
    url          => "${LOKI_SERVICE_URL}/loki/api/v1/push"  # пример: http://loki:3100/loki/api/v1/push
    http_method  => "post"
    content_type => "application/json"
    format       => "message"
    message      => "%{[@metadata][loki_json]}"
  }

  # Для отладки можно включить:
  # stdout { codec => rubydebug }
}