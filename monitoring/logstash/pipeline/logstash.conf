# Unified pipeline: FILE inputs (local bind mounts or network shares) → filters → push to Loki
# Источники: примонтированные каталоги /var/log/wt/{web1,web2,worker}
# Переключатель включения файлового источника: LOGSTASH_INPUT_FILES_ENABLED

input {
  file {
    id               => "files-web1"
    path             => ["${LOGSTASH_FILES_GLOB_WEB1}"]
    sincedb_path     => "/usr/share/logstash/data/sincedb/web1"
    start_position   => "end"
    mode             => "tail"
    codec => multiline {
      pattern => "${LOGSTASH_ML_PATTERN}"
      negate  => "${LOGSTASH_ML_NEGATE}"
      what    => "${LOGSTASH_ML_WHAT}"
      auto_flush_interval => "${LOGSTASH_ML_AUTO_FLUSH}"
    }
    add_field => { "[@metadata][source]" => "files" }
    add_field => { "[@metadata][source_role]" => "web1" }
  }
  file {
    id               => "files-web2"
    path             => ["${LOGSTASH_FILES_GLOB_WEB2}"]
    sincedb_path     => "/usr/share/logstash/data/sincedb/web2"
    start_position   => "end"
    mode             => "tail"
    codec => multiline {
      pattern => "${LOGSTASH_ML_PATTERN}"
      negate  => "${LOGSTASH_ML_NEGATE}"
      what    => "${LOGSTASH_ML_WHAT}"
      auto_flush_interval => "${LOGSTASH_ML_AUTO_FLUSH}"
    }
    add_field => { "[@metadata][source]" => "files" }
    add_field => { "[@metadata][source_role]" => "web2" }
  }
  file {
    id               => "files-worker"
    path             => ["${LOGSTASH_FILES_GLOB_WORKER}"]
    sincedb_path     => "/usr/share/logstash/data/sincedb/worker"
    start_position   => "end"
    mode             => "tail"
    codec => multiline {
      pattern => "${LOGSTASH_ML_PATTERN}"
      negate  => "${LOGSTASH_ML_NEGATE}"
      what    => "${LOGSTASH_ML_WHAT}"
      auto_flush_interval => "${LOGSTASH_ML_AUTO_FLUSH}"
    }
    add_field => { "[@metadata][source]" => "files" }
    add_field => { "[@metadata][source_role]" => "worker" }
  }
}

filter {
  # Выключатель файлового источника через .env (без top-level if)
  if [@metadata][source] == "files" and "${LOGSTASH_INPUT_FILES_ENABLED}" != "true" {
    drop { }
  }

  # job для Loki
  mutate { add_field => { "[@metadata][job]" => "${LOKI_JOB_LABEL}" } }

  # Определяем role (приоритет: мета от input → из path → fallback)
  ruby {
    code => '
      role = event.get("[@metadata][source_role]")
      unless role
        path = event.get("path").to_s
        role = if    path.include?("/web1") || path.include?("web-backend-1") then "web1"
               elsif path.include?("/web2") || path.include?("web-backend-2") then "web2"
               elsif path.include?("/worker")                                   then "worker"
               else nil
               end
      end
      role ||= (ENV["ROLE_FALLBACK"] || "unknown_role")
      event.set("role", role)
    '
  }

    # Извлекаем log_type из имени файла вида: xhttp_middleware_YYYY-MM-DD(.seq).log
  # А env берём из ENV_FALLBACK (например, dev)
  ruby {
    code => '
      path = (event.get("path") || "").to_s
      fname = File.basename(path)

      # log_type = всё до суффикса "_YYYY-MM-DD(.seq).log"
      log_type = nil
      if (m = fname.match(/\A([A-Za-z0-9_.-]+?)_\d{4}-\d{2}-\d{2}(?:\.\d+)?\.log\z/))
        log_type = m[1]
      end

      env      = (ENV["ENV_FALLBACK"]      || "unknown_env").to_s.downcase
      log_type = (log_type || ENV["LOG_TYPE_FALLBACK"] || "unknown_type").to_s.downcase

      event.set("env", env)
      event.set("log_type", log_type)
    '
  }

  # Готовим JSON для Loki (streams/labels/values)
  ruby {
    code => '
      require "json"
      job      = (event.get("[@metadata][job]") || "logs").to_s
      role     = (event.get("role")      || "").to_s
      env      = (event.get("env")       || "").to_s
      log_type = (event.get("log_type")  || "").to_s
      msg      = (event.get("message")   || "").to_s

      ts = event.get("@timestamp")
      ts_nano = (ts.respond_to?(:time) ? (ts.time.to_r * 1_000_000_000) : (Time.now.to_r * 1_000_000_000)).to_i.to_s

      payload = {
        "streams" => [
          {
            "stream" => { "job" => job, "role" => role, "env" => env, "log_type" => log_type },
            "values" => [[ ts_nano, msg ]]
          }
        ]
      }
      event.set("[@metadata][loki_json]", payload.to_json)
    '
  }
}

output {
  # HTTP push в Loki (host/port из .env)
  http {
    url          => "http://${HOST_NAME__LOKI}:${HOST_PORT__LOKI}/loki/api/v1/push"
    http_method  => "post"
    content_type => "application/json"
    format       => "message"
    message      => "%{[@metadata][loki_json]}"
    pool_max     => 50
    automatic_retries => 3
    retry_failed => true
  }
  # stdout { codec => rubydebug }  # для локальной отладки
}